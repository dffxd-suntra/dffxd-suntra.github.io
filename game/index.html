<!DOCTYPE html>
<html lang="en-us">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
        <title>Unity</title>
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <style>
            body {
                padding: 0;
                margin: 0;
                background-color: rgb(10,10,10);
                overflow: hidden;
            }
            div {
                padding: 0;
                margin: 0;
            }
            #gameBox {
                position: fixed;
            }
            #gamePage, #shadowBox {
                position: fixed;
                top: 0;
                left: 0;
                bottom: 0;
                right: 0;
            }
            #shadowBox {
                backdrop-filter: blur(40px);
            }
            #shadowPic {
                position: fixed;
            }
            #unityContainer {
                width: 100%;
                height: 100%;
                Border-radius: 5px;
            }
            #unityContainer > canvas {
                width: 100%;
                height: 100%;
                top: 0;
                left: 0;
                Border-radius: 5px;
            }
        </style>
    </head>
    <body>
        <div id="gamePage">
            <canvas id="shadowPic"></canvas>
            <div id="shadowBox">
                <div id="gameBox">
                    <div id="unityContainer"></div>
                </div>
            </div>
        </div>
        
        <script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/jquery/3.6.0/jquery.min.js" type="application/javascript"></script>
        <script src="Build/UnityLoader.js"></script>
        <script>
            let unityInstance;
            function showShadow() {
                // WEBGL独特的读取方式
                // 事实证明,就算是webgl转成imgdata再放到canvas里都比转成dataurl快
                let gameCtx = unityInstance.Module.ctx;
                let {
                    drawingBufferWidth: width,
                    drawingBufferHeight: height
                } = gameCtx;
                let imgData = new Uint8Array(width*height*4);
                gameCtx.readPixels(0, 0, width, height, gameCtx.RGBA, gameCtx.UNSIGNED_BYTE, imgData);
                imgData = new ImageData(new Uint8ClampedArray(imgData), width, height);
                let shadowCanvas = $("#shadowPic").get(0);
                shadowCanvas.width = width;
                shadowCanvas.height = height;
                shadowCanvas.getContext('2d').putImageData(imgData, 0, 0);
                // 实际上延迟1毫秒就行,因为要等当前堆栈清理完毕才能执行
                setTimeout(showShadow, 100);
            }
            function resizer(node, aspectRatio, canvasScale=1) {
                let w, h, ww, wh;
                ww = $(window).width();
                wh = $(window).height();
                if(ww/wh > aspectRatio) {
                    // 说明屏幕高度多了,那么高度就是撑满屏幕
                    h = wh * canvasScale;
                    w = h*aspectRatio;
                } else {
                    // 说明屏幕高度多了,那么宽度就是撑满屏幕
                    w = ww * canvasScale;
                    h = w/aspectRatio;
                }
                $(node).css({
                    "width": w,
                    "height": h,
                    "top": (wh-h)/2,
                    "left": (ww-w)/2
                });
            }
            $(document).ready(function () {
                // $("#gameBox").get(0).style["aspect-ratio"] = aspectRatio;
                $(window).resize(function () {
                    resizer($("#gameBox").get(0), 16/9, 0.9);
                    resizer($("#shadowPic").get(0), 16/9, 0.91);
                });
                resizer($("#gameBox").get(0), 16/9, 0.9);
                resizer($("#shadowPic").get(0), 16/9, 0.91);
                unityInstance = UnityLoader.instantiate("unityContainer", "Build/example.json", {
                    onProgress: function (info, progress) {
                        if(progress==1) {
                            showShadow();
                        }
                    },
                    Module: {
                        webglContextAttributes: {
                            preserveDrawingBuffer: true
                        }
                    }
                });
            });
        </script>
    </body>
</html>
